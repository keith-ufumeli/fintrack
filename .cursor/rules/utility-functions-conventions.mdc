---
description: Utility function conventions and patterns for shared helper functions
globs: lib/**/*.ts,utils/**/*.ts,**/utils.ts
alwaysApply: true
---

# Utility Functions Conventions

This document outlines the conventions and patterns used in utility functions and shared helper modules in the fintrack project.

## Utility Function Structure

### Import Organization
```typescript
// 1. Third-party library imports first
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

// 2. Internal imports (if any)
// import { someInternalUtil } from "./other-utils"
```

### Function Definition Patterns
```typescript
// Named export with explicit return type
export function functionName(...inputs: InputType[]): ReturnType {
  return implementation
}

// For utility functions that combine multiple libraries
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

## Class Name Utility Conventions

### The `cn` Function Pattern
The `cn` function is a critical utility that combines `clsx` and `tailwind-merge`:

```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

### Usage Patterns
```typescript
// Basic usage
className={cn("base-class", "conditional-class")}

// With conditional classes
className={cn(
  "base-class",
  isActive && "active-class",
  variant === "primary" && "primary-class"
)}

// With component variants
className={cn(componentVariants({ variant, size, className }))}

// Merging multiple class sources
className={cn(
  "base-class",
  props.className,
  conditionalClass
)}
```

## Utility Function Best Practices

### Function Naming
- Use descriptive, concise names: `cn`, `formatDate`, `validateEmail`
- Use camelCase for function names
- Use verbs for action functions: `merge`, `format`, `validate`
- Use nouns for getter functions: `getUser`, `findItem`

### Type Safety
```typescript
// Always use proper TypeScript types
export function utilityFunction(input: string): string {
  return input.toUpperCase()
}

// Use generic types when appropriate
export function createArray<T>(length: number, value: T): T[] {
  return Array(length).fill(value)
}

// Use union types for multiple input types
export function formatValue(value: string | number): string {
  return String(value)
}
```

### Parameter Handling
```typescript
// Use rest parameters for variable inputs
export function combine(...inputs: ClassValue[]): string {
  return inputs.join(" ")
}

// Use default parameters when appropriate
export function formatDate(date: Date, format: string = "YYYY-MM-DD"): string {
  // implementation
}

// Use object parameters for multiple options
export function createConfig(options: {
  theme: string
  size: "sm" | "md" | "lg"
  enabled?: boolean
}): Config {
  // implementation
}
```

## Library Integration Patterns

### Combining Multiple Libraries
```typescript
// Pattern: Import multiple related libraries
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

// Pattern: Create a utility that combines their functionality
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

### Type Re-exporting
```typescript
// Re-export types from libraries for convenience
export type { ClassValue } from "clsx"
export type { Config } from "some-library"

// Use in function signatures
export function utilityFunction(input: ClassValue): string {
  // implementation
}
```

## File Organization

### Single Purpose Files
- Each utility file should have a single, clear purpose
- `utils.ts` - General utilities
- `date-utils.ts` - Date manipulation functions
- `validation-utils.ts` - Validation helpers
- `format-utils.ts` - Formatting functions

### Export Patterns
```typescript
// Named exports (preferred)
export function utilityOne() { }
export function utilityTwo() { }

// Default export (use sparingly)
export default function mainUtility() { }

// Re-exports
export { utilityOne, utilityTwo } from "./other-utils"
```

## Common Utility Patterns

### Conditional Logic
```typescript
// Use ternary operators for simple conditions
export function getStatus(isActive: boolean): string {
  return isActive ? "active" : "inactive"
}

// Use logical operators for complex conditions
export function getClassName(base: string, condition: boolean, extra?: string): string {
  return cn(
    base,
    condition && "conditional-class",
    extra
  )
}
```

### Array and Object Manipulation
```typescript
// Array utilities
export function removeDuplicates<T>(array: T[]): T[] {
  return [...new Set(array)]
}

// Object utilities
export function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  return keys.reduce((result, key) => {
    result[key] = obj[key]
    return result
  }, {} as Pick<T, K>)
}
```

### Validation Utilities
```typescript
// Type guards
export function isString(value: unknown): value is string {
  return typeof value === "string"
}

// Validation functions
export function isValidEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
}
```

## Performance Considerations

### Memoization
```typescript
// Use for expensive computations
export function expensiveCalculation(input: number): number {
  // Cache results for repeated inputs
  const cache = new Map<number, number>()
  
  if (cache.has(input)) {
    return cache.get(input)!
  }
  
  const result = /* expensive computation */
  cache.set(input, result)
  return result
}
```

### Lazy Evaluation
```typescript
// Use for optional expensive operations
export function lazyFormat(value: string, formatter?: (val: string) => string): string {
  return formatter ? formatter(value) : value
}
```

## Testing Utilities

### Test Helpers
```typescript
// Create test utilities for consistent testing
export function createMockData<T>(overrides: Partial<T> = {}): T {
  return {
    // default values
    ...overrides
  } as T
}

// Utility for testing async functions
export function waitFor(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}
```

## Documentation

### JSDoc Comments
```typescript
/**
 * Combines class names using clsx and tailwind-merge
 * @param inputs - Class values to combine
 * @returns Merged class string
 * @example
 * cn("base-class", "conditional-class") // "base-class conditional-class"
 */
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs))
}
```

## Error Handling

### Graceful Degradation
```typescript
// Handle errors gracefully
export function safeParseJSON<T>(json: string, fallback: T): T {
  try {
    return JSON.parse(json)
  } catch {
    return fallback
  }
}
```

### Validation with Errors
```typescript
// Return validation results
export function validateInput(input: string): { valid: boolean; error?: string } {
  if (!input.trim()) {
    return { valid: false, error: "Input is required" }
  }
  return { valid: true }
}
```

This convention ensures consistent, maintainable, and performant utility functions throughout the project.